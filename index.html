<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Showroom Organizer - Arxzez</title>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <style>
        :root {
            --bg-primary: #f3f4f6;
            --bg-secondary: white;
            --bg-tertiary: #f9fafb;
            --border-primary: #d1d5db;
            --text-primary: #111827;
            --text-secondary: #6b7280;
            --text-accent: #fbbf24;
        }
        
        [data-theme="dark"] {
            --bg-primary: #111827;
            --bg-secondary: #1f2937;
            --bg-tertiary: #374151;
            --border-primary: #4b5563;
            --text-primary: #f9fafb;
            --text-secondary: #d1d5db;
            --text-accent: #fbbf24;
        }
        
        * { box-sizing: border-box; }
        body { 
            margin: 0; 
            font-family: Arial, sans-serif; 
            background-color: var(--bg-primary);
            color: var(--text-primary);
            transition: all 0.3s ease;
        }
        .container { padding: 1rem; max-width: 1400px; margin: 0 auto; }
        .header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; }
        .title { font-size: 1.5rem; font-weight: bold; }
        .theme-toggle { 
            padding: 8px 16px; 
            border: 1px solid var(--border-primary); 
            border-radius: 4px; 
            background: var(--bg-secondary); 
            color: var(--text-primary); 
            cursor: pointer; 
            font-size: 14px;
        }
        .theme-toggle:hover { background: var(--bg-tertiary); }
        .layout { display: flex; gap: 1rem; }
        .sidebar { width: 300px; flex-shrink: 0; }
        .main { flex: 1; display: flex; flex-direction: column; }
        .panel { 
            background: var(--bg-secondary); 
            border-radius: 8px; 
            border: 1px solid var(--border-primary); 
            padding: 1rem; 
            margin-bottom: 1rem; 
            transition: all 0.3s ease;
        }
        .display-panel { border: 2px solid #ef4444; }
        .btn { padding: 8px 16px; border: none; border-radius: 4px; cursor: pointer; color: white; margin: 2px; }
        .btn-blue { background: #3b82f6; } .btn-blue:hover { background: #2563eb; }
        .btn-green { background: #10b981; } .btn-green:hover { background: #059669; }
        .btn-red { background: #ef4444; } .btn-red:hover { background: #dc2626; }
        .btn-purple { background: #8b5cf6; } .btn-purple:hover { background: #7c3aed; }
        .spawn-showroom { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        .spawn-item { position: relative; display: flex; align-items: center; }
        .spawn-btn { 
            flex-grow: 1;
            padding: 8px; 
            border: 1px solid var(--border-primary); 
            background: var(--bg-secondary); 
            border-radius: 4px; 
            cursor: pointer; 
            font-size: 12px; 
            color: var(--text-primary);
            text-align: center;
        }
        .spawn-btn:hover { background: var(--bg-tertiary); }
        .delete-btn {
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border-primary);
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 12px;
            cursor: pointer;
            margin-left: 4px;
        }
        .delete-btn:hover { background-color: var(--bg-tertiary); }
        .showroom-and-controls { 
            display: flex;
            gap: 1rem;
            align-items: flex-start;
            flex: 1;
        }
        .showroom-container { 
            border: 2px solid var(--border-primary); 
            overflow: auto; 
            background: var(--bg-secondary);
            width: fit-content;
            height: fit-content;
            flex-shrink: 0;
            padding: 1rem;
            position: relative; 
        }
        .showroom { 
            position: relative; 
            user-select: none; 
            background-image: 
                linear-gradient(to right, var(--border-primary) 1px, transparent 1px), 
                linear-gradient(to bottom, var(--border-primary) 1px, transparent 1px);
            background-size: 8px 8px;
            cursor: grab;
            touch-action: none;
            flex-shrink: 0;
            border-right: 1px solid var(--border-primary);
            border-bottom: 1px solid var(--border-primary);
        }
        .display { 
            position: absolute; 
            border: 2px solid #1f2937; 
            border-radius: 4px; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            color: white; 
            font-weight: bold; 
            font-size: 12px; 
            cursor: grab; 
            touch-action: none;
        }
        .display.selected { border: 4px solid var(--text-accent); z-index: 10; }
        .display-text { text-align: center; }
        .display-input { 
            width: 100%; 
            padding: 8px; 
            border: 1px solid var(--border-primary); 
            border-radius: 4px; 
            background: var(--bg-secondary);
            color: var(--text-primary);
        }
        .display-row { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 1rem; margin-bottom: 1rem; }
        .type-showroom { 
            display: grid; 
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); 
            gap: 8px; 
        }
        .type-btn { padding: 8px; border-radius: 4px; cursor: pointer; text-align: center; font-size: 12px; font-weight: bold; color: white; }
        .storage-display { 
            display: inline-block; 
            margin: 2px; 
            border: 1px solid #1f2937; 
            border-radius: 4px; 
            width: 32px; 
            height: 32px; 
            color: white; 
            font-weight: bold; 
            font-size: 8px; 
            text-align: center;
            line-height: 30px;
        }
        .storage-display:hover { opacity: 0.8; }
        .storage-area { min-height: 80px; border: 2px dashed var(--border-primary); border-radius: 8px; padding: 8px; background: var(--bg-tertiary); }
        .storage-area-highlight { border-color: #3b82f6 !important; background-color: #eff6ff !important; }
        .hidden { display: none; }
        .dragging { opacity: 0.5; z-index: 100; }
        .legend-item { display: flex; align-items: center; margin-bottom: 8px; font-size: 12px; }
        .legend-colors { display: flex; gap: 2px; }
        .legend-color { width: 12px; height: 12px; border-radius: 2px; }
        
        .right-panel {
            flex-shrink: 0;
            width: 300px;
        }
        .custom-display-panel {
            width: 300px;
        }
        .input-group {
            display: flex;
            align-items: flex-end;
            gap: 8px;
        }
        .input-group > div {
            flex: 1;
        }
        .color-input {
            width: 100%;
            height: 38px;
            padding: 0;
            border: 1px solid var(--border-primary);
            border-radius: 4px;
            background: var(--bg-secondary);
            cursor: pointer;
        }
        .modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--bg-secondary);
            border: 2px solid var(--border-primary);
            border-radius: 8px;
            padding: 1.5rem;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            z-index: 1000;
            width: 90%;
            max-width: 400px;
        }
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.2);
            z-index: 999;
        }
        .modal-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            margin-top: 1.5rem;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;
        const ReactDOM = window.ReactDOM;

        const INITIAL_TIER = 5;
        const STUD_SIZE = 8;
        const TIER_CONFIGS = {
            1: { width: 50, height: 82, name: 'Tier 1' },
            2: { width: 58, height: 82, name: 'Tier 2' },
            3: { width: 66, height: 82, name: 'Tier 3' },
            4: { width: 74, height: 82, name: 'Tier 4' },
            5: { width: 82, height: 82, name: 'Tier 5' },
            6: { width: 82, height: 82, name: 'Tier 6' },
            7: { width: 82, height: 82, name: 'Tier 7' },
            8: { width: 88, height: 82, name: 'Tier 8' },
            9: { width: 88, height: 93, name: 'Tier 9' }
        };
        const INITIAL_TYPE_COLORS = {
            water: '#4A90E2', psychic: '#E91E63', darkness: '#424242', lightning: '#FFC107',
            grass: '#4CAF50', metal: '#9E9E9E', fighting: '#FF5722', fire: '#FF9800'
        };
        const INITIAL_DISPLAY_CONFIGS = {
            1: { width: 4, height: 4, name: 'Basic Stand' },
            2: { width: 8, height: 8, name: 'Small Display' },
            3: { width: 8, height: 8, name: 'Habitat Display' },
            4: { width: 10, height: 10, name: 'Cloud Display' },
            5: { width: 16, height: 8, name: 'Tree Display' },
            6: { width: 12, height: 12, name: 'Mountain Display' },
            7: { width: 12, height: 12, name: 'Steampunk Display' },
            8: { width: 14, height: 14, name: 'Ring Display' },
            9: { width: 10, height: 10, name: 'Volcano Display' }
        };
        const INITIAL_DISPLAY_AVAILABLE_TYPES = {
            1: ['fire', 'grass', 'water'], 2: ['darkness', 'lighting'], 3: ['grass', 'water'],
            4: ['darkness', 'lighting', 'water'], 5: ['darkness', 'grass', 'psychic'], 
            6: ['water', 'psychic', 'fighting'], 7: ['metal', 'fighting', 'psychic'],
            8: ['water','fighting','lighting'], 9: ['water','fire','lighting']
        };

        const App = () => {
            const [displays, setdisplays] = useState([]);
            const [storeddisplays, setStoreddisplays] = useState([]);
            const [dragState, setDragState] = useState(null);
            const [nextdisplayId, setNextdisplayId] = useState(0);
            const [selecteddisplayId, setSelecteddisplayId] = useState(null);
            const [isDarkMode, setIsDarkMode] = useState(false);
            const [showCustomDisplays, setShowCustomDisplays] = useState(false);
            const [customDisplay, setCustomDisplay] = useState({ name: '', width: 8, height: 8, types: [] });
            const [customType, setCustomType] = useState({ name: '', color: '#FF6B6B' });
            const [typeColors, setTypeColors] = useState(INITIAL_TYPE_COLORS);
            const [displayConfigs, setDisplayConfigs] = useState(INITIAL_DISPLAY_CONFIGS);
            const [displayAvailableTypes, setDisplayAvailableTypes] = useState(INITIAL_DISPLAY_AVAILABLE_TYPES);
            const [confirmDelete, setConfirmDelete] = useState(null);
            const [confirmCreateType, setConfirmCreateType] = useState(null);
            const [customDisplayWarning, setCustomDisplayWarning] = useState(null);
            const [noSpaceWarning, setNoSpaceWarning] = useState(null);
            const [currentTier, setCurrentTier] = useState(INITIAL_TIER);
            const [showShowroomSizeModal, setShowShowroomSizeModal] = useState(false);

            const showroomRef = useRef(null);
            const startDragPos = useRef(null);

            const showroomWidth = TIER_CONFIGS[currentTier].width;
            const showroomHeight = TIER_CONFIGS[currentTier].height;

            useEffect(() => {
                const savedTheme = localStorage.getItem('theme');
                if (savedTheme) {
                    setIsDarkMode(savedTheme === 'dark');
                }
            }, []);

            useEffect(() => {
                document.documentElement.setAttribute('data-theme', isDarkMode ? 'dark' : 'light');
                localStorage.setItem('theme', isDarkMode ? 'dark' : 'light');
            }, [isDarkMode]);

            const getShowroomPosition = (clientX, clientY) => {
                const rect = showroomRef.current.getBoundingClientRect();
                const x = Math.floor((clientX - rect.left) / STUD_SIZE);
                const y = Math.floor((clientY - rect.top) / STUD_SIZE);
                return { x: Math.max(0, Math.min(x, showroomWidth - 1)), y: Math.max(0, Math.min(y, showroomHeight - 1)) };
            };

            const checkCollision = (display1, display2) => {
                const b1W = display1.rotation === 90 ? display1.height : display1.width;
                const b1H = display1.rotation === 90 ? display1.width : display1.height;
                const b2W = display2.rotation === 90 ? display2.height : display2.width;
                const b2H = display2.rotation === 90 ? display2.width : display2.height;
                return !(display1.x >= display2.x + b2W || display2.x >= display1.x + b1W || display1.y >= display2.y + b2H || display2.y >= display1.y + b1H);
            };

            const findFirstValidPositionOnShowroom = (movingdisplay, otherdisplays) => {
                const width = movingdisplay.rotation === 90 ? movingdisplay.height : movingdisplay.width;
                const height = movingdisplay.rotation === 90 ? movingdisplay.width : movingdisplay.height;
                
                for (let y = 0; y <= showroomHeight - height; y++) {
                    for (let x = 0; x <= showroomWidth - width; x++) {
                        const tempdisplay = { ...movingdisplay, x, y };
                        const hasCollision = otherdisplays.some(display => checkCollision(tempdisplay, display));
                        if (!hasCollision) {
                            return { x, y };
                        }
                    }
                }
                return null;
            };

            const findNearestValidPosition = (movingdisplay, otherdisplays, startX, startY) => {
                const width = movingdisplay.rotation === 90 ? movingdisplay.height : movingdisplay.width;
                const height = movingdisplay.rotation === 90 ? movingdisplay.width : movingdisplay.height;
                
                const tempdisplay = { ...movingdisplay, x: startX, y: startY };
                if (startX >= 0 && startY >= 0 && startX + width <= showroomWidth && startY + height <= showroomHeight) {
                    const hasCollision = otherdisplays.some(display => checkCollision(tempdisplay, display));
                    if (!hasCollision) {
                        return { x: startX, y: startY };
                    }
                }
            
                const directions = [{ dx: 1, dy: 0 }, { dx: -1, dy: 0 }, { dx: 0, dy: 1 }, { dx: 0, dy: -1 }];
                let minDistance = Infinity;
                let bestPosition = null;
            
                for (const { dx, dy } of directions) {
                    for (let i = 1; i < Math.max(showroomWidth, showroomHeight); i++) {
                        const x = startX + i * dx;
                        const y = startY + i * dy;
            
                        if (x < 0 || y < 0 || x + width > showroomWidth || y + height > showroomHeight) {
                            break;
                        }
            
                        const testdisplay = { ...movingdisplay, x, y };
                        const hasCollision = otherdisplays.some(display => checkCollision(testdisplay, display));
                        
                        if (!hasCollision) {
                            const distance = Math.abs(x - startX) + Math.abs(y - startY);
                            if (distance < minDistance) {
                                minDistance = distance;
                                bestPosition = { x, y };
                            }
                            break;
                        }
                    }
                }
                
                return bestPosition;
            };

            const handleMouseDown = (e) => {
                const pos = getShowroomPosition(e.clientX, e.clientY);
                const display = displays.find(b => {
                    const width = b.rotation === 90 ? b.height : b.width;
                    const height = b.rotation === 90 ? b.width : b.height;
                    return pos.x >= b.x && pos.x < b.x + width && pos.y >= b.y && pos.y < b.y + height;
                });
                
                if (display) {
                    setSelecteddisplayId(display.id);
                    setDragState({
                        displayId: display.id,
                        offsetX: pos.x - display.x,
                        offsetY: pos.y - display.y
                    });
                    startDragPos.current = { x: display.x, y: display.y };
                } else {
                    setSelecteddisplayId(null);
                }
            };

            const handleMouseMove = (e) => {
                if (dragState) {
                    const pos = getShowroomPosition(e.clientX, e.clientY);
                    const display = displays.find(b => b.id === dragState.displayId);
                    if (!display) return;
                    
                    const width = display.rotation === 90 ? display.height : display.width;
                    const height = display.rotation === 90 ? display.width : display.height;
                    
                    setdisplays(prevdisplays => prevdisplays.map(b => 
                        b.id === dragState.displayId ? { 
                            ...b, 
                            x: Math.max(0, Math.min(pos.x - dragState.offsetX, showroomWidth - width)), 
                            y: Math.max(0, Math.min(pos.y - dragState.offsetY, showroomHeight - height)) 
                        } : b
                    ));
                }
            };

            const handleMouseUp = () => {
                if (dragState) {
                    const draggeddisplay = displays.find(b => b.id === dragState.displayId);
                    if (draggeddisplay) {
                        const otherdisplays = displays.filter(b => b.id !== dragState.displayId);
                        const newPos = { 
                            x: draggeddisplay.x, 
                            y: draggeddisplay.y,
                            width: draggeddisplay.rotation === 90 ? draggeddisplay.height : draggeddisplay.width,
                            height: draggeddisplay.rotation === 90 ? draggeddisplay.width : draggeddisplay.height
                        };
                        
                        const hasCollision = otherdisplays.some(display => checkCollision(newPos, display));
                        if (hasCollision) {
                            const validPosition = findNearestValidPosition(draggeddisplay, otherdisplays, draggeddisplay.x, draggeddisplay.y);
                            if (validPosition) {
                                setdisplays(prevdisplays => prevdisplays.map(b =>
                                    b.id === dragState.displayId ? { ...b, x: validPosition.x, y: validPosition.y } : b
                                ));
                            } else {
                                setdisplays(prevdisplays => prevdisplays.map(b =>
                                    b.id === dragState.displayId ? { ...b, x: startDragPos.current.x, y: startDragPos.current.y } : b
                                ));
                                setNoSpaceWarning({ message: 'The display could not be placed there and has been returned to its original position.' });
                            }
                        }
                    }
                }
                setDragState(null);
            };

            const handleTouchStart = (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                handleMouseDown({ clientX: touch.clientX, clientY: touch.clientY });
            };

            const handleTouchMove = (e) => {
                e.preventDefault();
                if (dragState) {
                    const touch = e.touches[0];
                    handleMouseMove({ clientX: touch.clientX, clientY: touch.clientY });
                }
            };

            const handleTouchEnd = () => {
                handleMouseUp();
            };

            const handleStoreddisplayClick = (displayId) => {
                const displayToRetrieve = storeddisplays.find(b => b.id === displayId);
                if (displayToRetrieve) {
                    const newdisplay = { ...displayToRetrieve, id: nextdisplayId };
                    const otherdisplays = [...displays, ...storeddisplays.filter(b => b.id !== displayId)];

                    const validPosition = findFirstValidPositionOnShowroom(newdisplay, otherdisplays);

                    if (validPosition) {
                        newdisplay.x = validPosition.x;
                        newdisplay.y = validPosition.y;
                        setdisplays(prev => [...prev, newdisplay]);
                        setStoreddisplays(prev => prev.filter(b => b.id !== displayId));
                        setNextdisplayId(nextdisplayId + 1);
                        setSelecteddisplayId(newdisplay.id);
                    } else {
                        setNoSpaceWarning({ message: 'No valid spot found for the display. It will remain in storage.' });
                    }
                }
            };
            
            const storedisplay = () => {
                const displayToStore = displays.find(b => b.id === selecteddisplayId);
                if (displayToStore) {
                    setdisplays(prevdisplays => prevdisplays.filter(b => b.id !== selecteddisplayId));
                    setStoreddisplays(prevStored => [...prevStored, displayToStore]);
                    setSelecteddisplayId(null);
                }
            };
            
            const spawndisplay = (displayType) => {
                const config = displayConfigs[displayType];
                const availableTypes = displayAvailableTypes[displayType];
                
                let newdisplay = {
                    id: nextdisplayId, 
                    displayType: parseInt(displayType), 
                    type: availableTypes[0],
                    width: config.width, 
                    height: config.height, 
                    x: 2, 
                    y: 2, 
                    rotation: 0
                };
                
                const otherdisplays = [...displays, ...storeddisplays];
                let validPosition = findFirstValidPositionOnShowroom(newdisplay, otherdisplays);
                
                if (!validPosition) {
                    const rotateddisplay = {
                        ...newdisplay,
                        rotation: 90,
                    };
                    validPosition = findFirstValidPositionOnShowroom(rotateddisplay, otherdisplays);
                    if (validPosition) {
                        newdisplay = rotateddisplay;
                    }
                }

                if (validPosition) {
                    newdisplay.x = validPosition.x;
                    newdisplay.y = validPosition.y;
                    setdisplays(prevdisplays => [...prevdisplays, newdisplay]);
                    setNextdisplayId(nextdisplayId + 1);
                } else {
                    setNoSpaceWarning({ message: `No space found.` });
                }
            };

            const rotatedisplay = () => {
                setdisplays(prevdisplays => {
                    const displayToRotate = prevdisplays.find(b => b.id === selecteddisplayId);
                    if (!displayToRotate) return prevdisplays;

                    const newRotation = displayToRotate.rotation === 0 ? 90 : 0;
                    const rotateddisplay = { ...displayToRotate, rotation: newRotation };
                    
                    const otherdisplays = prevdisplays.filter(b => b.id !== selecteddisplayId);
                    const validPosition = findNearestValidPosition(rotateddisplay, otherdisplays, displayToRotate.x, displayToRotate.y);

                    if (validPosition) {
                        return prevdisplays.map(b =>
                            b.id === selecteddisplayId ? { ...rotateddisplay, x: validPosition.x, y: validPosition.y } : b
                        );
                    } else {
                        setNoSpaceWarning({ message: 'Cannot rotate this display. There is no available space near its location to rotate.' });
                        return prevdisplays;
                    }
                });
            };

            const changedisplayType = (e) => {
                const newType = e.target.value;
                setdisplays(prevdisplays => prevdisplays.map(b => 
                    b.id === selecteddisplayId ? { ...b, type: newType } : b
                ));
            };

            const deletedisplay = () => {
                setdisplays(prevdisplays => prevdisplays.filter(b => b.id !== selecteddisplayId));
                setSelecteddisplayId(null);
            };
            
            const clearLayout = () => {
                setdisplays([]);
                setStoreddisplays([]);
                setSelecteddisplayId(null);
            };

            const handleCreateCustomType = () => {
                const name = customType.name.trim().toLowerCase();
                if (!name || typeColors[name]) {
                    setCustomDisplayWarning({ title: "Invalid Name", message: "Please enter a unique name for the new type." });
                    return;
                }
                setConfirmCreateType({ name, color: customType.color });
            };

            const confirmCreateTypeAction = () => {
                const { name, color } = confirmCreateType;
                setTypeColors(prev => ({ ...prev, [name]: color }));
                setCustomType({ name: '', color: '#FF6B6B' });
                setConfirmCreateType(null);
            };
            
            const cancelCreateType = () => {
                setConfirmCreateType(null);
            };

            const createCustomDisplay = () => {
                const { name, types, width, height } = customDisplay;
                
                if (!name || types.length === 0) {
                    setCustomDisplayWarning({
                        title: "Missing Information",
                        message: "Please enter a display name and select at least one type before creating."
                    });
                    return;
                }
                
                const newDisplayType = Math.max(...Object.keys(displayConfigs).map(Number), 0) + 1;
                
                setDisplayConfigs(prev => ({ ...prev, [newDisplayType]: { ...customDisplay, name } }));
                setDisplayAvailableTypes(prev => ({ ...prev, [newDisplayType]: types }));
                
                spawndisplay(newDisplayType);
                setCustomDisplay({ name: '', width: 8, height: 8, types: [] });
            };

            const toggleCustomType = (type) => {
                setCustomDisplay(prev => {
                    const newTypes = prev.types.includes(type)
                        ? prev.types.filter(t => t !== type)
                        : [...prev.types, type];
                    return { ...prev, types: newTypes };
                });
            };
            
            const handleCustomWidthChange = (e) => {
                const value = Math.max(1, parseInt(e.target.value) || 1);
                setCustomDisplay(prev => ({ ...prev, width: value }));
            };
            
            const handleCustomHeightChange = (e) => {
                const value = Math.max(1, parseInt(e.target.value) || 1);
                setCustomDisplay(prev => ({ ...prev, height: value }));
            };

            const handleTierChange = (e) => {
                const newTier = parseInt(e.target.value);
                if (newTier !== currentTier) {
                    setShowShowroomSizeModal(true);
                    setCurrentTier(newTier);
                }
            };
            
            const confirmShowroomSizeChange = () => {
                clearLayout();
                setShowShowroomSizeModal(false);
            };

            const deleteCustomTypes = () => {
                const customTypes = Object.keys(typeColors).filter(type => !INITIAL_TYPE_COLORS.hasOwnProperty(type));
                const typesToDelete = customTypes.filter(type => customDisplay.types.includes(type));

                if (typesToDelete.length === 0) {
                    setCustomDisplayWarning({ title: "No Types Selected", message: "Please select the custom types you want to delete." });
                    return;
                }

                setConfirmDelete({
                    type: 'types',
                    items: typesToDelete,
                    message: `Are you sure you want to delete these custom types?\n\n- ${typesToDelete.join('\n- ')}\n\nThis will remove them from all custom displays on the board.`
                });
            };

            const confirmDeleteAction = () => {
                const { type, items, displayType } = confirmDelete;
                if (type === 'types') {
                    const newAvailableTypes = {};
                    for (const dt in displayAvailableTypes) {
                        newAvailableTypes[dt] = displayAvailableTypes[dt].filter(t => !items.includes(t));
                    }
                    setDisplayAvailableTypes(newAvailableTypes);

                    const newTypeColors = { ...typeColors };
                    items.forEach(t => delete newTypeColors[t]);
                    setTypeColors(newTypeColors);

                    setdisplays(prevdisplays => prevdisplays.map(b => {
                        if (items.includes(b.type)) {
                            const newType = newAvailableTypes[b.displayType]?.[0] || 'water';
                            return { ...b, type: newType };
                        }
                        return b;
                    }));
                    setStoreddisplays(prevStored => prevStored.map(b => {
                         if (items.includes(b.type)) {
                            const newType = newAvailableTypes[b.displayType]?.[0] || 'water';
                            return { ...b, type: newType };
                        }
                        return b;
                    }));

                    setCustomDisplay(prev => ({ ...prev, types: prev.types.filter(t => !items.includes(t)) }));
                } else if (type === 'display') {
                    setDisplayConfigs(prev => {
                        const newState = { ...prev };
                        delete newState[displayType];
                        return newState;
                    });
                    
                    setDisplayAvailableTypes(prev => {
                        const newState = { ...prev };
                        delete newState[displayType];
                        return newState;
                    });
                    
                    setdisplays(prev => prev.filter(b => b.displayType !== parseInt(displayType)));
                    setStoreddisplays(prev => prev.filter(b => b.displayType !== parseInt(displayType)));
                    
                    if (selecteddisplayId && displays.find(b => b.id === selecteddisplayId)?.displayType === parseInt(displayType)) {
                        setSelecteddisplayId(null);
                    }
                }
                setConfirmDelete(null);
            };

            const handleDeleteCustomDisplayClick = (displayType) => {
                const config = displayConfigs[displayType];
                setConfirmDelete({
                    type: 'display',
                    displayType,
                    name: config.name,
                    message: `Are you sure you want to delete the display '${config.name}'? This will permanently remove all instances of this display from the board and storage.`
                });
            };

            const cancelDelete = () => {
                setConfirmDelete(null);
            };

            const exportLayout = () => {
                const layoutData = {
                    timestamp: new Date().toISOString(), currentTier: currentTier, customTypes: typeColors,
                    displayConfigs: displayConfigs, displayAvailableTypes: displayAvailableTypes,
                    displays: displays.map(display => ({
                        displayType: display.displayType, type: display.type, x: display.x, y: display.y, rotation: display.rotation
                    })),
                    storeddisplays: storeddisplays.map(display => ({
                        displayType: display.displayType, type: display.type, rotation: display.rotation
                    }))
                };
    
                const dataStr = JSON.stringify(layoutData, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = `display-layout-${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            };

            const importLayout = (event) => {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const layoutData = JSON.parse(e.target.result);
                        if (layoutData.customTypes) setTypeColors(layoutData.customTypes);
                        if (layoutData.displayConfigs) setDisplayConfigs(layoutData.displayConfigs);
                        if (layoutData.displayAvailableTypes) setDisplayAvailableTypes(layoutData.displayAvailableTypes);
                        if (layoutData.currentTier) setCurrentTier(layoutData.currentTier);

                        if (layoutData.displays && Array.isArray(layoutData.displays)) {
                            const importeddisplays = layoutData.displays.map((displayData, index) => ({
                                id: index, displayType: displayData.displayType, type: displayData.type,
                                width: layoutData.displayConfigs[displayData.displayType]?.width || 0,
                                height: layoutData.displayConfigs[displayData.displayType]?.height || 0,
                                x: displayData.x || 0, y: displayData.y || 0, rotation: displayData.rotation || 0
                            }));
                            const importedStored = (layoutData.storeddisplays || []).map((displayData, index) => ({
                                id: importeddisplays.length + index, displayType: displayData.displayType, type: displayData.type,
                                width: layoutData.displayConfigs[displayData.displayType]?.width || 0,
                                height: layoutData.displayConfigs[displayData.displayType]?.height || 0,
                                x: 0, y: 0, rotation: displayData.rotation || 0
                            }));

                            setdisplays(importeddisplays);
                            setStoreddisplays(importedStored);
                            setNextdisplayId(importeddisplays.length + importedStored.length);
                            setSelecteddisplayId(null);
                        }
                    } catch (error) {
                        setNoSpaceWarning({ message: 'Error importing layout file.' });
                    }
                };
                reader.readAsText(file);
                event.target.value = '';
            };

            const selecteddisplay = displays.find(b => b.id === selecteddisplayId);
            const customTypes = Object.keys(typeColors).filter(type => !INITIAL_TYPE_COLORS.hasOwnProperty(type));

            const totalArea = displays.reduce((sum, display) => {
                const width = display.rotation === 90 ? display.height : display.width;
                const height = display.rotation === 90 ? display.width : display.height;
                return sum + (width * height);
            }, 0);
            const totalAvailable = showroomWidth * showroomHeight;

            return (
                <div className="container">
                    <div className="header">
                        <div className="title">Showroom Organizer - Arxzez</div>
                        <button className="theme-toggle" onClick={() => setIsDarkMode(!isDarkMode)}>
                            {isDarkMode ? 'üåô Dark Mode ·ìö·òè·ó¢' : '‚òÄÔ∏è Light Mode'}
                        </button>
                    </div>

                    <div className="layout">
                        <div className="sidebar">
                            <div className="panel">
                                <h3 style={{ marginBottom: '1rem' }}>Controls</h3>
                                <div style={{ marginBottom: '1rem' }}>
                                    <label style={{ display: 'block', fontWeight: 'bold', marginBottom: '4px', fontSize: '14px' }}>Showroom Tier:</label>
                                    <select
                                        value={currentTier}
                                        onChange={handleTierChange}
                                        className="display-input"
                                    >
                                        {Object.entries(TIER_CONFIGS).map(([tier, config]) => (
                                            <option key={tier} value={tier}>
                                                {config.name} ({config.width}x{config.height})
                                            </option>
                                        ))}
                                    </select>
                                    <div style={{ fontSize: '12px', color: 'var(--text-secondary)', marginTop: '4px' }}>
                                        Current: {showroomWidth}x{showroomHeight} studs
                                    </div>
                                </div>
                                <button className="btn btn-blue" style={{ width: '100%', marginBottom: '8px' }} onClick={clearLayout}>Clear Showroom</button>
                                <button className="btn btn-green" style={{ width: '100%', marginBottom: '8px' }} onClick={exportLayout}>Export Layout</button>
                                <div style={{ position: 'relative', width: '100%', marginBottom: '8px' }}>
                                    <input type="file" accept=".json" onChange={importLayout} style={{ position: 'absolute', width: '100%', height: '100%', opacity: 0, cursor: 'pointer' }} />
                                    <button className="btn btn-purple" style={{ width: '100%', pointerEvents: 'none' }}>Import Layout</button>
                                </div>
                                <button className="btn btn-red" style={{ width: '100%', marginBottom: '8px' }} onClick={() => setShowCustomDisplays(!showCustomDisplays)}>
                                    {showCustomDisplays ? 'Close Custom Displays' : 'Open Custom Displays'}
                                </button>
                            </div>

                            <div className="panel">
                                <h3 style={{ marginBottom: '1rem' }}>Displays</h3>
                                <div className="spawn-showroom">
                                    {Object.entries(displayConfigs).map(([displayType, config]) => (
                                        <div key={displayType} className="spawn-item">
                                            <button 
                                                className="spawn-btn" 
                                                onClick={() => spawndisplay(displayType)}
                                            >
                                                <span style={{ whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis' }}>{config.name}</span>
                                                <br/>
                                                ({config.width}x{config.height})
                                            </button>
                                            {parseInt(displayType) > 9 && (
                                                <button
                                                    className="delete-btn"
                                                    onClick={() => handleDeleteCustomDisplayClick(displayType)}
                                                >
                                                    üóëÔ∏è
                                                </button>
                                            )}
                                        </div>
                                    ))}
                                </div>
                            </div>
                            
                            <div className="panel">
                                <h3 style={{ marginBottom: '1rem' }}>Storage</h3>
                                <div style={{ fontSize: '12px', color: 'var(--text-secondary)', marginBottom: '8px' }}>Click a display to take it out</div>
                                <div className="storage-area">
                                    {storeddisplays.map(display => {
                                        const config = displayConfigs[display.displayType] || { name: 'Custom' };
                                        return (
                                            <div 
                                                key={display.id}
                                                className="storage-display"
                                                style={{ backgroundColor: typeColors[display.type], cursor: 'pointer' }}
                                                onClick={() => handleStoreddisplayClick(display.id)}
                                            >
                                                {config.name.split(' ')[0]}
                                            </div>
                                        );
                                    })}
                                </div>
                            </div>

                            <div className="panel">
                                <div>Area used: {totalArea}/{totalAvailable} studs ({((totalArea / totalAvailable) * 100).toFixed(1)}%)</div>
                                <div>Showroom: {showroomWidth}x{showroomHeight}</div>
                            </div>
                        </div>

                        <div className="main">
                            <div className="showroom-and-controls">
                                <div className="showroom-container">
                                    <div 
                                        className="showroom" 
                                        ref={showroomRef}
                                        onMouseDown={handleMouseDown}
                                        onMouseMove={handleMouseMove}
                                        onMouseUp={handleMouseUp}
                                        onMouseLeave={handleMouseUp}
                                        onTouchStart={handleTouchStart}
                                        onTouchMove={handleTouchMove}
                                        onTouchEnd={handleTouchEnd}
                                        style={{ width: showroomWidth * STUD_SIZE, height: showroomHeight * STUD_SIZE }}
                                    >
                                        {displays.map(display => {
                                            const width = display.rotation === 90 ? display.height : display.width;
                                            const height = display.rotation === 90 ? display.width : display.height;
                                            return (
                                                <div 
                                                    key={display.id}
                                                    className={`display ${selecteddisplayId === display.id ? 'selected' : ''}`}
                                                    style={{
                                                        left: display.x * STUD_SIZE,
                                                        top: display.y * STUD_SIZE,
                                                        width: width * STUD_SIZE,
                                                        height: height * STUD_SIZE,
                                                        backgroundColor: typeColors[display.type]
                                                    }}
                                                >
                                                    <div className="display-text">
                                                        <div>{displayConfigs[display.displayType]?.name?.split(' ')[0]}</div>
                                                        <div style={{ textTransform: 'capitalize' }}>{display.type}</div>
                                                        <div>{width}x{height}</div>
                                                        {display.rotation === 90 && <div>‚Üª</div>}
                                                    </div>
                                                </div>
                                            );
                                        })}
                                    </div>
                                </div>
                                
                                <div className="right-panel">
                                    {selecteddisplay && (
                                        <div id="selectedPanel" className="panel" style={{ border: '2px solid var(--text-accent)' }}>
                                            <div style={{ display: 'flex', flexDirection: 'column', gap: '1rem' }}>
                                                <div id="selectedInfo" style={{ fontWeight: 'bold' }}>
                                                    Selected: {displayConfigs[selecteddisplay.displayType]?.name}
                                                </div>
                                                <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                                                    <span>Type:</span>
                                                    <select value={selecteddisplay.type} onChange={changedisplayType} style={{ padding: '4px', border: '1px solid var(--border-primary)', background: 'var(--bg-secondary)', color: 'var(--text-primary)' }}>
                                                        {displayAvailableTypes[selecteddisplay.displayType]?.map(type => (
                                                            <option key={type} value={type}>{type.charAt(0).toUpperCase() + type.slice(1)}</option>
                                                        ))}
                                                    </select>
                                                </div>
                                                <button className="btn btn-blue" onClick={storedisplay}>Store Display</button>
                                                <button className="btn btn-green" onClick={rotatedisplay} id="rotateBtn">
                                                    Rotate {selecteddisplay.rotation === 90 ? '(Vertical)' : '(Horizontal)'}
                                                </button>
                                                <button className="btn btn-red" onClick={deletedisplay}>Delete Display</button>
                                            </div>
                                        </div>
                                    )}

                                    {showCustomDisplays && (
                                        <div id="customDisplays" className="panel display-panel custom-display-panel">
                                            <h3 style={{ marginBottom: '1rem' }}>Custom Types</h3>
                                            <div className="input-group" style={{ marginBottom: '1rem' }}>
                                                <div>
                                                    <label style={{ display: 'block', fontWeight: 'bold', marginBottom: '4px' }}>Type:</label>
                                                    <input type="text" value={customType.name} onChange={(e) => setCustomType(prev => ({ ...prev, name: e.target.value }))} className="display-input" maxLength="12" />
                                                </div>
                                                <div>
                                                    <label style={{ display: 'block', fontWeight: 'bold', marginBottom: '4px' }}>Color:</label>
                                                    <input type="color" value={customType.color} onChange={(e) => setCustomType(prev => ({ ...prev, color: e.target.value }))} className="color-input" />
                                                </div>
                                                <div style={{ display: 'flex', alignItems: 'flex-end' }}>
                                                    <button className="btn btn-blue" onClick={handleCreateCustomType}>Create</button>
                                                </div>
                                            </div>
                                            <h3 style={{ marginBottom: '1rem' }}>Custom Displays</h3>
                                            <div className="display-row">
                                                <div>
                                                    <label style={{ display: 'block', fontWeight: 'bold', marginBottom: '4px' }}>Display Name:</label>
                                                    <input type="text" value={customDisplay.name} onChange={(e) => setCustomDisplay(prev => ({ ...prev, name: e.target.value }))} className="display-input" maxLength="25" />
                                                </div>
                                                <div>
                                                    <label style={{ display: 'block', fontWeight: 'bold', marginBottom: '4px' }}>Width (studs):</label>
                                                    <input type="number" value={customDisplay.width} onChange={handleCustomWidthChange} className="display-input" min="1" max={showroomWidth} />
                                                </div>
                                                <div>
                                                    <label style={{ display: 'block', fontWeight: 'bold', marginBottom: '4px' }}>Height (studs):</label>
                                                    <input type="number" value={customDisplay.height} onChange={handleCustomHeightChange} className="display-input" min="1" max={showroomHeight} />
                                                </div>
                                            </div>
                                            <div style={{ marginBottom: '1rem' }}>
                                                <label style={{ display: 'block', fontWeight: 'bold', marginBottom: '8px' }}>Available Types (click to select):</label>
                                                <div className="type-showroom">
                                                    {Object.keys(typeColors).map(type => (
                                                        <div 
                                                            key={type}
                                                            className="type-btn"
                                                            style={{ 
                                                                backgroundColor: typeColors[type],
                                                                border: customDisplay.types.includes(type) ? '2px solid #3b82f6' : '1px solid var(--border-primary)', 
                                                                color: typeColors[type] === '#424242' ? '#fff' : '#000',
                                                            }}
                                                            onClick={() => toggleCustomType(type)}
                                                        >
                                                            {type.charAt(0).toUpperCase() + type.slice(1)}
                                                        </div>
                                                    ))}
                                                </div>
                                            </div>
                                            <div style={{ display: 'flex', gap: '8px' }}>
                                                <button className="btn btn-blue" onClick={createCustomDisplay}>Create</button>
                                                {customTypes.length > 0 && <button className="btn btn-red" onClick={deleteCustomTypes}>Delete Selected Types</button>}
                                            </div>
                                        </div>
                                    )}
                                </div>
                            </div>
                        </div>
                    </div>
                    {(confirmDelete || confirmCreateType || customDisplayWarning || noSpaceWarning || showShowroomSizeModal) && (
                        <>
                            <div className="modal-overlay"></div>
                            <div className="modal">
                                {confirmDelete && (
                                    <>
                                        <h3 style={{ marginTop: 0 }}>Confirm Deletion</h3>
                                        <p>{confirmDelete.message}</p>
                                        <div className="modal-buttons">
                                            <button className="btn btn-red" onClick={confirmDeleteAction}>Delete</button>
                                            <button className="btn btn-blue" onClick={cancelDelete}>Cancel</button>
                                        </div>
                                    </>
                                )}
                                {confirmCreateType && (
                                    <>
                                        <h3 style={{ marginTop: 0 }}>Confirm Creation</h3>
                                        <p>Are you sure you want to create the new type '{confirmCreateType.name}'?</p>
                                        <div className="modal-buttons">
                                            <button className="btn btn-blue" onClick={confirmCreateTypeAction}>Create</button>
                                            <button className="btn btn-red" onClick={cancelCreateType}>Cancel</button>
                                        </div>
                                    </>
                                )}
                                {customDisplayWarning && (
                                    <>
                                        <h3 style={{ marginTop: 0 }}>{customDisplayWarning.title}</h3>
                                        <p>{customDisplayWarning.message}</p>
                                        <div className="modal-buttons">
                                            <button className="btn btn-blue" onClick={() => setCustomDisplayWarning(null)}>OK</button>
                                        </div>
                                    </>
                                )}
                                {noSpaceWarning && (
                                    <>
                                        <h3 style={{ marginTop: 0 }}>Cannot Place Display</h3>
                                        <p>{noSpaceWarning.message}</p>
                                        <div className="modal-buttons">
                                            <button className="btn btn-blue" onClick={() => setNoSpaceWarning(null)}>OK</button>
                                        </div>
                                    </>
                                )}
                                {showShowroomSizeModal && (
                                    <>
                                        <h3 style={{ marginTop: 0 }}>Change Showroom Tier</h3>
                                        <p>Changing the showroom tier will clear the board and all stored displays. Are you sure?</p>
                                        <div className="modal-buttons">
                                            <button className="btn btn-red" onClick={confirmShowroomSizeChange}>Confirm</button>
                                            <button className="btn btn-blue" onClick={() => setShowShowroomSizeModal(false)}>Cancel</button>
                                        </div>
                                    </>
                                )}
                            </div>
                        </>
                    )}
                </div>
            );
        };

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>




